package core

import (
	"archive/zip"
	"errors"
	"fmt"
	"math/rand"
	"os"
	"strings"
	"time"
)

func AddUser(username, password string) error {
	//add user
	if username == "" {
		username = randomStr(6)
	}
	if password == "" {
		password = randomStr(6)
	}

	addUserAPI := "/v1/auth/users"
	data := fmt.Sprintf("username=%s&password=%s", username, password)
	response, err := client.R().SetBody(data).Post(addUserAPI)
	if err != nil {
		return err
	}
	result := response.String()
	if !strings.Contains(result, "create user ok!") {
		err = errors.New("create user fail " + result)
		return err
	}
	fmt.Printf("add user success\n\tusername: %s\n\tpassword: %s\n", username, password)

	// add role
	addRoleAPI := "/v1/auth/roles"
	role := randomStr(6)
	data = fmt.Sprintf("role=%s&username=%s", role, username)
	response, err = client.R().SetBody(data).Post(addRoleAPI)
	result = response.String()
	if err != nil {
		return err
	}
	if !strings.Contains(result, "add role ok!") {
		err = errors.New("create role fail " + result)
		return err
	}
	fmt.Println("success add role to user: ", username)

	//add permission
	permissionAPI := "/v1/auth/permissions"
	namespaces := GetNamespaces()
	for _, namespace := range namespaces {
		data = fmt.Sprintf("role=%s&resource=%s%%3A%%2A%%3A%%2A&action=rw", role, namespace)
		response, err = client.R().SetBody(data).Post(permissionAPI)
		if err != nil {
			return err
		}
	}
	fmt.Println("success add permissions to user: ", username)

	return nil
}

func GetConfig(namespace string) ([]ConfigItem, error) {
	configAPI := fmt.Sprintf("/v1/cs/configs?dataId=&group=&appName=&config_tags=&pageNo=1&pageSize=99&tenant=%s&search=accurate&username=", namespace)
	var response ConfigResponse
	_, err := client.R().SetSuccessResult(&response).Get(configAPI)
	if err != nil {
		return nil, err
	}
	return response.PageItems, nil
}

func Export(namespace, filename string) error {
	if namespace != "" {
		err := exportByNameSpace(namespace, filename)
		return err
	} else {
		namespaces := GetNamespaces()
		if filename == "" {
			filename = fmt.Sprintf("nacos_export_config_all_%v.zip", time.Now().Unix())
		}

		file, err := os.Create(filename)
		if err != nil {
			return err
		}
		defer file.Close()

		writer := zip.NewWriter(file)
		defer writer.Close()

		for _, item := range namespaces {
			i := fmt.Sprintf("nacos_export_config_%s_%v.zip", item, time.Now().Unix())
			bytes, err := getConfigZipStream(item)
			if err != nil {
				return err
			}
			zipWriter, err := writer.Create(i)
			if err != nil {
				return err
			}
			zipWriter.Write(bytes)
		}
		return nil
	}
}

func exportByNameSpace(namespace string, filename string) error {
	zipStream, err := getConfigZipStream(namespace)
	if err != nil {
		return err
	}

	if filename == "" {
		filename = fmt.Sprintf("nacos_export_config_%s_%v.zip", namespace, time.Now().Unix())
	}
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.Write(zipStream)
	if err != nil {
		return err
	}
	fmt.Println("export config in file: ", filename)
	return nil
}

func getConfigZipStream(namespace string) ([]byte, error) {
	exportAPI := fmt.Sprintf("/v1/cs/configs?export=true&tenant=%s&group=&appName=&ids=", namespace)
	response, err := client.R().Get(exportAPI)
	if err != nil {
		return nil, err
	}
	return response.Bytes(), nil
}

func GetNamespaces() []string {
	api := "/v1/console/namespaces"
	var result []string
	var namespaces NamespaceResp
	_, err := client.R().SetSuccessResult(&namespaces).Get(api)

	if err != nil {
		fmt.Println(err)
		return nil
	}

	for _, item := range namespaces.Data {
		result = append(result, item.Namespace)
	}

	return result
}

// 获取随机字符串
func randomStr(n int) string {
	//randSource := rand.New(rand.NewSource(time.Now().Unix()))
	const (
		letterIdxBits = 6                    // 6 bits to represent a letter index
		letterIdxMask = 1<<letterIdxBits - 1 // All 1-bits, as many as letterIdxBits
		letterIdxMax  = 63 / letterIdxBits   // # of letter indices fitting in 63 bits
		letterBytes   = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	)
	randBytes := make([]byte, n)
	for i, cache, remain := n-1, rand.Int63(), letterIdxMax; i >= 0; {
		if remain == 0 {
			cache, remain = rand.Int63(), letterIdxMax
		}
		if idx := int(cache & letterIdxMask); idx < len(letterBytes) {
			randBytes[i] = letterBytes[idx]
			i--
		}
		cache >>= letterIdxBits
		remain--
	}
	return string(randBytes)
}
